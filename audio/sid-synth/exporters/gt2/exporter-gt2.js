// Minimal GoatTracker-oriented exporter producing assembly data tables
import { instruments } from '../../synth.js';
import { patternManager } from '../../pattern-manager.js';

function noteStrToSemitone(noteStr) {
  // Returns semitone number relative to C-0 (0..95). 0 for rest.
  if (!noteStr || noteStr === 'R' || noteStr === '---') return 0;
  const map = { 'C-':0,'C#':1,'D-':2,'D#':3,'E-':4,'F-':5,'F#':6,'G-':7,'G#':8,'A-':9,'A#':10,'B-':11 };
  if (noteStr.length < 3) return 0;
  const nn = noteStr.substring(0,2);
  const oct = parseInt(noteStr.charAt(2),10);
  if (!(nn in map) || isNaN(oct)) return 0;
  const semitone = oct * 12 + map[nn];
  return Math.max(0, Math.min(95, semitone));
}

function hexByte(n){ return '$' + (n & 0xFF).toString(16).padStart(2,'0').toUpperCase(); }

export function exportGoatTrackerASM(songTitle = 'sid_tracker_song') {
  const currentPattern = patternManager.getCurrentPattern();
  const plen = currentPattern.length;
  const patternRows = [[],[],[]];

  // Collect per-voice rows: (note, instrument)
  for (let step = 0; step < plen; step++) {
    for (let v = 0; v < 3; v++) {
      const s = currentPattern.getStepData(v, step) || {};
      const note = noteStrToSemitone(s.note);
      const inst = (s.instrument != null) ? (s.instrument & 0xFF) : 0;
      patternRows[v].push({ note, inst });
    }
  }

  // Build instruments table: [AD, SR, waveform, PWlo, PWHi]
  // waveform here should contain GT2-style control bits (w/o gate). Map from our instrument fields.
  const instLines = [];
  for (let i = 0; i < instruments.length; i++) {
    const inst = instruments[i] || {};
    const ad = inst.ad != null ? inst.ad : 0x00;
    const sr = inst.sr != null ? inst.sr : 0x00;
    const wf = inst.waveform != null ? (inst.waveform & 0xF0) : 0x10; // default triangle
    const pw = inst.pulseWidth != null ? inst.pulseWidth : 0x0800;
    instLines.push(`    .byte ${hexByte(ad)}, ${hexByte(sr)}, ${hexByte(wf)}, ${hexByte(pw & 0xFF)}, ${hexByte((pw>>8)&0xFF)}`);
  }
  if (instLines.length === 0) instLines.push('    .byte $00,$00,$10,$00,$08');

  // Build pattern data per voice: rows of (note, instrument)
  const pattSections = [];
  for (let v = 0; v < 3; v++) {
    const rows = patternRows[v];
    const bytes = rows.map(r => `${hexByte(r.note)}, ${hexByte(r.inst)}`);
    const lines = [];
    for (let i = 0; i < bytes.length; i+=8) {
      lines.push('    .byte ' + bytes.slice(i, i+8).join(', '));
    }
    pattSections.push([`PATTERN_V${v}:`, ...lines].join('\n'));
  }

  // Order lists (simple: one pattern index 0 looping) â€“ adapt as needed
  const orderLists = [0,1,2].map(v => `ORDER_V${v}:\n    .byte $00  ; pattern index 0`);

  const header = [
    `; GoatTracker data-only export`,
    `; Title: ${songTitle}`,
    `; Rows per pattern: ${plen}`,
    `; Generated by sid-exporter (gt2)`,
    '',
    `ROWS_PER_PATTERN = ${plen}`,
    '',
    '; Instruments: AD, SR, WF(no gate), PWlo, PWhi',
    'INSTRUMENTS:',
    ...instLines,
    '',
  ].join('\n');

  const asm = [
    header,
    '; Patterns: per-voice rows of (note, instrument)',
    pattSections.join('\n\n'),
    '',
    '; Orderlists: per-voice sequence of pattern indices',
    orderLists.join('\n\n'),
    '',
    '; Notes: 0=rest, else semitone index from C-0 (0..95).',
  ].join('\n');

  return asm;
}

export function downloadGoatTrackerASM(title = 'sid_tracker_song') {
  try {
    const asm = exportGoatTrackerASM(title);
    const blob = new Blob([asm], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${title.replace(/[^a-zA-Z0-9-_]/g,'_')}.asm`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error('GT2 ASM export failed', e);
    alert('GT2 ASM export failed. See console for details.');
  }
}

